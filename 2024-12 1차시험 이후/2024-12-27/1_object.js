/*
객체와 변경 불가성
1. 변경불가성(immutability)
 - 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴
   - 변경 불가능한 객체, 변경 가능한 객체 2가지 있음.
   - 변경 불가성 = 함수형 프로그래밍의 핵심원리.
   - 객체는 참저형태로 전달하고 전달받음.

객체는 왜 변경 불가인가? 
그리고 어떤 객체들이 변경이 불가한가?
변경불가 객체 : 원시타입(primitive type)
String, Number, Boolean, Null, undifined
 - 변경 불가인 이유 
    : 객체를 참조하고 있다 가정하면, 
      변경시 공유하는 모든 장소에서 영향을 받아서
 - 복제, 비교를 위한 조작의 단순화를 통한 성능개선

강사님이 데이터 타입에 따른 저장방식을 설명하고계시는데
아마 지금 객체타입인지, 원시타입인지에 따라서 
메모리 저장방식이 갈린다는걸 설명하려고 하시는듯

var str = 'hello';
str = 'hi';
console.log(str) // hi

----------------------------
따로 찾아본것.
원시 타입의 메모리 저장 및 접근
  원시 타입(숫자, 문자열, 불리언, null, undefined, 심볼)의 경우:
    값 자체가 콜 스택(Call Stack)에 직접 저장됩니다
    변수는 콜 스택에 저장된 값의 메모리 주소를 참조합니다
    변수를 통해 값에 접근할 때, 콜 스택에서 직접 값을 읽어옵니다

객체 타입의 메모리 저장 및 접근
  객체 타입(객체, 배열, 함수 등)의 경우:
    객체의 실제 데이터는 메모리 힙(Memory Heap)에 저장됩니다
    콜 스택에는 메모리 힙에 저장된 객체의 참조 값(메모리 주소)이 저장됩니다
    변수는 콜 스택에 저장된 참조 값을 가리킵니다
    객체에 접근할 때, 먼저 콜 스택에서 참조 값을 읽고, 이 참조 값을 통해 메모리 힙에 저장된 실제 객체 데이터에 접근합니다6

메모리 접근 과정
  원시 타입: 변수 → 콜 스택 → 값
  객체 타입: 변수 → 콜 스택 → 참조 값 → 메모리 힙 → 객체 데이터

메모리 구조 때문에 원시 타입은 값에 의한 전달(call by value)이 일어나고, 
객체 타입은 참조에 의한 전달(call by reference)
-----------------------------

원시 타입외의 객체들은 가변
객체를 불변으로 바꾸는 메소드

Object.freeze, assign <- 성능이슈로 가급적 안쓰는걸 권장

immutable.js 라는 라이브러리를 사용하는걸 권장.
 -> List, Stack, Map, OrderedMap, Set, Record -> 불변 데이터 구조를 제공
 

*/


